import { logger } from '@poppinss/cliui';
import { paramCase as kebabCase, pascalCase } from 'change-case';
import type { Rule } from 'eslint';
import type { JSONSchema4 } from 'json-schema';
import { compile } from 'json-schema-to-typescript';
import { execSync } from 'node:child_process';
import { existsSync, mkdirSync, rmSync, writeFileSync } from 'node:fs';
import { dirname, join, resolve } from 'node:path';
import { URL, fileURLToPath } from 'node:url';
import { format as prettierFormat, type Config } from 'prettier';
import { dedent } from 'ts-dedent';

type PluginRules = Record<string, Rule.RuleModule>;

interface Plugin {
  name: string;
  prefix?: string;
  module: string;
  rules?: PluginRules;
}

/**
 * Our custom prettier configuration.
 */
const PRETTIER_OPTIONS: Config = {
  plugins: ['prettier-plugin-organize-imports'],
  parser: 'typescript',
  singleQuote: true,
  trailingComma: 'all',
};

/**
 * Format the given content with Prettier.
 */
function format(content: string): Promise<string> {
  return prettierFormat(content, PRETTIER_OPTIONS);
}

/**
 * Simple class helper to build a JSDoc comment.
 */
class JsDocBuilder {
  private readonly content: string[] = [];

  public static build(): JsDocBuilder {
    return new JsDocBuilder();
  }

  public add(line?: string): JsDocBuilder {
    if (line) {
      this.content.push(line);
    }

    return this;
  }

  public output(): string {
    return [
      //
      '/**',
      ...this.content.map((line) => ` * ${line}`),
      ' */',
    ].join('\n');
  }
}

/**
 * Map of plugins for which the script will generate rule files.
 */
export const PLUGIN_REGISTRY: Readonly<Record<string, Plugin>> = {
  deprecation: {
    name: 'Deprecation',
    module: 'eslint-plugin-deprecation',
  },
  eslint: {
    name: 'Eslint',
    module: 'eslint',
  },
  'typescript-eslint': {
    name: 'TypeScript',
    prefix: '@typescript-eslint',
    module: '@typescript-eslint/eslint-plugin',
  },
  import: {
    name: 'Import',
    module: 'eslint-plugin-import',
  },
  'eslint-comments': {
    name: 'EslintComments',
    module: 'eslint-plugin-eslint-comments',
  },
  'graphql-eslint': {
    name: 'GraphQL',
    prefix: '@graphql-eslint',
    module: '@graphql-eslint/eslint-plugin',
  },
  jsdoc: {
    name: 'JSDoc',
    prefix: 'jsdoc',
    module: 'eslint-plugin-jsdoc',
  },
  jsonc: {
    name: 'Jsonc',
    module: 'eslint-plugin-jsonc',
  },
  'jsx-a11y': {
    name: 'JsxA11y',
    module: 'eslint-plugin-jsx-a11y',
  },
  mdx: {
    name: 'Mdx',
    module: 'eslint-plugin-mdx',
  },
  n: {
    name: 'N',
    module: 'eslint-plugin-n',
  },
  node: {
    name: 'Node',
    module: 'eslint-plugin-node',
  },
  promise: {
    name: 'Promise',
    module: 'eslint-plugin-promise',
  },
  react: {
    name: 'React',
    module: 'eslint-plugin-react',
  },
  'react-hooks': {
    name: 'ReactHooks',
    module: 'eslint-plugin-react-hooks',
  },
  sonarjs: {
    name: 'SonarJS',
    prefix: 'sonarjs',
    module: 'eslint-plugin-sonarjs',
  },
  spellcheck: {
    name: 'Spellcheck',
    module: 'eslint-plugin-spellcheck',
  },
  'testing-library': {
    name: 'TestingLibrary',
    module: 'eslint-plugin-testing-library',
  },
  unicorn: {
    name: 'Unicorn',
    module: 'eslint-plugin-unicorn',
  },
  vitest: {
    name: 'Vitest',
    module: 'eslint-plugin-vitest',
  },
  vue: {
    name: 'Vue',
    module: 'eslint-plugin-vue',
  },
  'vue-i18n': {
    name: 'VueI18n',
    prefix: '@intlify/vue-i18n',
    module: '@intlify/eslint-plugin-vue-i18n',
  },
  'vue-pug': {
    name: 'VuePug',
    module: 'eslint-plugin-vue-pug',
  },
  yml: {
    name: 'Yml',
    module: 'eslint-plugin-yml',
  },
} as const;

async function loadPlugin(plugin: Plugin): Promise<Plugin> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const mod: any = await import(plugin.module);
  const rules: PluginRules =
    plugin.module === 'eslint'
      ? Object.fromEntries(
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          new mod.Linter().getRules().entries(),
        )
      : mod.rules ?? mod.default.rules;
  return { ...plugin, rules };
}

/**
 * Remove unnecessary comments that are generated by `json-schema-to-typescript`.
 */
function cleanJsDoc(content: string): string {
  const patterns: RegExp[] = [
    /\* This interface was referenced by .+ JSON-Schema definition/,
    /\* via the `.+` "/,
  ];

  return content
    .split('\n')
    .filter((line) => !patterns.some((ignoredLine) => ignoredLine.test(line)))
    .join('\n');
}

/**
 * Replace some types that are generated by `json-schema-to-typescript`.
 */
function patchTypes(content: string): string {
  const replacements: Array<{
    pattern: RegExp;
    replacement: string;
  }> = [
    {
      pattern:
        /\(string & \{\s*\[k: string\]: any\s*\} & \{\s*\[k: string\]: any\s*\}\)\[\]/,
      replacement: 'string[]',
    },
  ];

  for (const { pattern, replacement } of replacements) {
    content = content.replace(pattern, replacement);
  }

  return content;
}

/**
 * Generate a type from the given JSON schema.
 */
async function generateTypeFromSchema(
  schema: JSONSchema4,
  typeName: string,
): Promise<string> {
  schema = JSON.parse(
    JSON.stringify(schema).replace(/#\/items\/0\/\$defs\//g, '#/$defs/'),
  );
  let result: string = await compile(schema, typeName, {
    format: false,
    bannerComment: '',
    style: {
      singleQuote: true,
      trailingComma: 'all',
    },
    unknownAny: false,
  });

  result = cleanJsDoc(result);
  result = patchTypes(result);

  return result;
}

const __dirname: string = fileURLToPath(new URL('.', import.meta.url));

class RuleFile {
  private content: string = '';

  private readonly rulePath: string;
  private readonly ruleNamePascalCase: string;

  private isSchemaArray!: boolean;
  private mainSchema?: JSONSchema4;
  private sideSchema?: JSONSchema4;
  private thirdSchema?: JSONSchema4;

  public constructor(
    private readonly plugin: Plugin,
    private readonly pluginDirectory: string,
    private readonly ruleName: string,
    private readonly rule: Rule.RuleModule,
  ) {
    this.ruleNamePascalCase = pascalCase(this.ruleName);
    this.rulePath = resolve(this.pluginDirectory, `${ruleName}.d.ts`);
    this.assignSchemasInfo();
  }

  private assignSchemasInfo(): void {
    const schema: JSONSchema4 | JSONSchema4[] | undefined =
      this.rule.meta?.schema;
    // eslint-disable-next-line @typescript-eslint/typedef
    const isArray = Array.isArray(schema);

    this.mainSchema = isArray ? schema[0] : schema;
    this.sideSchema = isArray && schema.length > 1 ? schema[1] : undefined;
    this.thirdSchema = isArray && schema.length > 2 ? schema[2] : undefined;
    this.isSchemaArray = isArray;
  }

  /**
   * Append the `import type { RuleConfig } from '../rule-config'` at the top of the file.
   */
  public appendRuleConfigImport(): void {
    const nestedDepth: number = this.ruleName.split('/').length;
    const ruleConfigImportPath: string = `${'../'.repeat(
      nestedDepth,
    )}rule-config`;
    this.content += `import type { RuleConfig } from '${ruleConfigImportPath}'\n\n`;
  }

  /**
   * Build the rule description to append to the JSDoc.
   */
  public buildDescription(): string {
    let description: string = this.rule.meta?.docs?.description ?? '';

    description = description.charAt(0).toUpperCase() + description.slice(1);

    if (description.length > 0 && !description.endsWith('.')) {
      description += '.';
    }

    return description.replace('*/', '');
  }

  /**
   * Build the `@see` url to the rule documentation to append to the JSDoc.
   */
  public buildSeeDocLink(): string {
    const { meta } = this.rule;
    const seeDocLink: string = meta?.docs?.url
      ? `@see [${this.ruleName}](${meta.docs.url})`
      : '';

    return seeDocLink;
  }

  /**
   * Generate a JSDoc with the rule description and `@see` url.
   */
  public generateTypeJsDoc(): string {
    return JsDocBuilder.build()
      .add(this.buildDescription())
      .add(' ')
      .add(this.rule.meta?.deprecated ? '@deprecated' : '')
      .add(this.rule.meta?.deprecated ? ' ' : '')
      .add(this.buildSeeDocLink())
      .output();
  }

  /**
   * Generate a type from a JSON schema and append it to the file content.
   */
  private async appendJsonSchemaType(
    schema: JSONSchema4,
    comment: string,
  ): Promise<void> {
    const type: string = await generateTypeFromSchema(
      schema,
      this.ruleNamePascalCase + comment,
    );

    const jsdoc: string = JsDocBuilder.build().add(`${comment}.`).output();
    this.content += `\n${jsdoc}`;
    this.content += `\n${type}\n`;
  }

  /**
   * Generate and append types for the rule schemas.
   */
  private async appendRuleSchemaTypes(): Promise<void> {
    if (this.thirdSchema) {
      await this.appendJsonSchemaType(this.thirdSchema, 'Setting');
    }

    if (this.sideSchema) {
      await this.appendJsonSchemaType(this.sideSchema, 'Config');
    }

    if (this.mainSchema) {
      await this.appendJsonSchemaType(this.mainSchema, 'Option');
    }
  }

  /**
   * Append the rule type options to the file content.
   */
  private appendRuleOptions(): void {
    const ruleName: string = this.ruleNamePascalCase;

    let type: string = '';
    if (!this.isSchemaArray) {
      type = `${ruleName}Option`;
    } else if (this.thirdSchema) {
      type = `[${ruleName}Option?, ${ruleName}Config?, ${ruleName}Setting?]`;
    } else if (this.sideSchema) {
      type = `[${ruleName}Option?, ${ruleName}Config?]`;
    } else if (this.mainSchema) {
      type = `[${ruleName}Option?]`;
    }

    this.content += JsDocBuilder.build().add('Options.').output() + '\n';
    this.content += `export type ${ruleName}Options = ${type}\n\n`;
  }

  /**
   * Append the rule config type to the file content.
   */
  private appendRuleConfig(): void {
    const ruleName: string = this.ruleNamePascalCase;
    const genericContent: string = this.mainSchema
      ? `${ruleName}Options`
      : '[]';

    this.content += this.generateTypeJsDoc() + '\n';
    this.content += `export type ${ruleName}RuleConfig = RuleConfig<${genericContent}>;\n\n`;
  }

  /**
   * Scoped rule name ESLint config uses.
   */
  private prefixedRuleName(): string {
    const { prefix, name } = this.plugin;
    let rulePrefix: string = (prefix ?? kebabCase(name)) + '/';

    if (name === 'Eslint') {
      rulePrefix = '';
    }

    return `${rulePrefix}${this.ruleName}`;
  }

  /**
   * Append the final rule interface to the file content.
   */
  private appendRule(): void {
    const ruleName: string = this.ruleNamePascalCase;

    this.content += this.generateTypeJsDoc() + '\n';

    this.content += `export interface ${ruleName}Rule {`;
    this.content += `${this.generateTypeJsDoc()}\n`;
    this.content += `'${this.prefixedRuleName()}': ${ruleName}RuleConfig;`;
    this.content += '}';
  }

  /**
   * Create the directory of the rule file if it doesn't exist.
   */
  private createRuleDirectory(): void {
    const subPath: string = dirname(this.rulePath);
    if (!existsSync(subPath)) {
      mkdirSync(subPath, { recursive: true });
    }
  }

  /**
   * Generate a file with the rule typings.
   */
  public async generate(): Promise<string> {
    this.appendRuleConfigImport();
    await this.appendRuleSchemaTypes();

    if (this.mainSchema) {
      this.appendRuleOptions();
    }

    this.appendRuleConfig();
    this.appendRule();

    this.content = await format(this.content);

    return this.content;
  }

  /**
   * Must be called after `generate()` to write the file.
   */
  public writeGeneratedContent(): void {
    this.createRuleDirectory();

    writeFileSync(this.rulePath, this.content);
  }

  /**
   * Apply a patch to the generated content if a diff file exists for it.
   *
   * Must be called after `generate()`.
   */
  public applyPatch(): void {
    const pathParts: string[] = this.rulePath.split('/');
    const ruleFileName: string = pathParts[pathParts.length - 1] ?? '';
    const rulePlugin: string = pathParts[pathParts.length - 2] ?? '';

    const diffFile: string = resolve(
      __dirname,
      'diffs',
      'rules',
      rulePlugin,
      `${ruleFileName}.diff`,
    );

    const ruleName: string = this.prefixedRuleName();

    if (existsSync(diffFile)) {
      logger.logUpdate(logger.colors.yellow(`  🧹 Adjusting ${ruleName}`));
      logger.logUpdatePersist();

      execSync(`git apply ${diffFile}`);
    }
  }
}

interface FailedRule {
  ruleName: string;
  err: unknown;
}

/**
 * Generate the `index.d.ts` file for the plugin's rules that will re-export all rules.
 */
async function generateRuleIndexFile(
  pluginDirectory: string,
  { rules, name }: Plugin,
  failedRules: FailedRule[],
): Promise<void> {
  if (!rules) {
    throw new Error(
      `Plugin ${name} doesn't have any rules. Did you forget to load them?`,
    );
  }

  const generatedRules: string[] = Object.keys(rules).filter(
    (ruleName) =>
      !failedRules.some((failedRule) => failedRule.ruleName === ruleName),
  );

  /**
   * Build all the import statements for the rules.
   */
  const rulesImports: string = generatedRules
    .map((name) => `import type { ${pascalCase(name)}Rule } from './${name}';`)
    .join('\n');

  /**
   * Build the exported type that is an intersection of all the rules.
   */
  const rulesFinalIntersection: string = generatedRules
    .map((name) => `${pascalCase(name)}Rule`)
    .join(' & ');

  const pluginRulesType: string = dedent(`
    ${JsDocBuilder.build().add(`All ${name} rules.`).output()}
    export type ${name}Rules = ${rulesFinalIntersection};
  `);

  /**
   * Write the final `index.d.ts` file.
   */
  const fileContent: string = dedent(`
    ${rulesImports}

    ${pluginRulesType}
  `);

  const indexPath: string = join(pluginDirectory, 'index.d.ts');
  writeFileSync(indexPath, await format(fileContent));
}

/**
 * Print a report after having generated rules files for a plugin.
 */
function printGenerationReport(
  rules: Array<[string, Rule.RuleModule]>,
  failedRules: FailedRule[],
): void {
  const msg: string = `  ✅ Generated ${
    rules.length - failedRules.length
  } rules`;
  logger.logUpdate(logger.colors.green(msg));
  logger.logUpdatePersist();

  if (failedRules.length) {
    logger.log(logger.colors.red(`  ❌ Failed ${failedRules.length} rules`));
    failedRules.forEach(({ ruleName, err }) => {
      logger.log(logger.colors.red(`    - ${ruleName}: ${String(err)}`));
    });
  }

  logger.log('');
}

/**
 * Generate a `.d.ts` file for each rule in the given plugin.
 */
async function generateRulesFiles(
  plugin: Plugin,
  pluginDirectory: string,
): Promise<{ failedRules: FailedRule[] }> {
  const failedRules: FailedRule[] = [];

  const pluginRules: PluginRules | undefined = plugin.rules;
  if (!pluginRules) {
    throw new Error(
      `Plugin ${plugin.name} doesn't have any rules. Did you forget to load them?`,
    );
  }

  const rules: Array<[string, Rule.RuleModule]> = Object.entries(pluginRules);
  for (const [ruleName, rule] of rules) {
    logger.logUpdate(logger.colors.yellow(`  Generating > ${ruleName}`));

    const ruleFile: RuleFile = new RuleFile(
      plugin,
      pluginDirectory,
      ruleName,
      rule,
    );
    try {
      await ruleFile.generate();
      ruleFile.writeGeneratedContent();
      ruleFile.applyPatch();
    } catch (err) {
      failedRules.push({ ruleName, err });
    }
  }

  printGenerationReport(rules, failedRules);

  return { failedRules };
}

/**
 * If it doesn't exist, create the directory that will contain the plugin's rule files.
 */
function createPluginDirectory(
  pluginName: string,
  targetDirectory?: string,
): string {
  const rulesDirectory: string = join(
    __dirname,
    targetDirectory ?? '../../src/rules',
  );
  const pluginDirectory: string = join(rulesDirectory, pluginName);

  if (existsSync(pluginDirectory)) {
    rmSync(pluginDirectory, { recursive: true, force: true });
  }

  mkdirSync(pluginDirectory, { mode: 0o755, recursive: true });

  return pluginDirectory;
}

export interface RunOptions {
  plugins?: string[];
  targetDirectory?: string;
}

export async function run(options: RunOptions = {}): Promise<void> {
  const { plugins, targetDirectory } = options;

  const wantedPlugins: string[] = plugins ?? Object.keys(PLUGIN_REGISTRY);

  for (const pluginName of wantedPlugins) {
    const plugin: Plugin | undefined = PLUGIN_REGISTRY[pluginName];
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} doesn't exist.`);
    }

    logger.info(`Generating ${plugin.name} rules.`);
    logger.logUpdate(
      logger.colors.yellow(`  Loading plugin > ${plugin.module}`),
    );
    const loadedPlugin: Plugin = await loadPlugin(plugin);

    const pluginDir: string = createPluginDirectory(
      pluginName,
      targetDirectory,
    );
    const { failedRules } = await generateRulesFiles(loadedPlugin, pluginDir);

    await generateRuleIndexFile(pluginDir, loadedPlugin, failedRules);
  }
}
