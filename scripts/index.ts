import { promises as fs } from 'node:fs';
import { join } from 'node:path';

import { Logger } from '@poppinss/cliui';
import { pascalCase as originalPascalCase } from 'change-case';
import type { Rule } from 'eslint';
import type { JSONSchema4 } from 'json-schema';
import { compile } from 'json-schema-to-typescript';
import colors from 'picocolors';

/**
 * Enhanced pascalCase that handles common edge cases where change-case
 * doesn't properly capitalize certain technical terms.
 */
function pascalCase(str: string): string {
  const result = originalPascalCase(str);

  // Handle common technical terms that should be properly capitalized
  return result
    .replace(/F16round/g, 'F16Round')
    .replace(/Log1p/g, 'Log1P')
    .replace(/Log2/g, 'Log2')
    .replace(/Log10/g, 'Log10')
    .replace(/H1/g, 'H1');
  // Add more cases as needed
}

import { ExtendsCollector } from './extends.ts';
import {
  PLUGIN_REGISTRY,
  type LoadedPlugin,
  type PluginEntry,
} from './registry.ts';
import { concatDoc, format, RegionReplacer } from './text.ts';

const logger = new Logger();

async function loadPlugin(entry: PluginEntry): Promise<LoadedPlugin> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let mod: any = await entry.import();
  mod = mod.default ?? mod;

  if (entry.id === 'eslint-js') {
    const js = mod.default || mod;
    // We need the actual rule objects (not just config), so we still use ESLint Linter
    const { Linter } = await import('eslint');
    const rules = Object.fromEntries(
      new Linter({ configType: 'eslintrc' }).getRules().entries(),
    );

    return {
      entry,
      plugin: { rules, configs: js.configs },
    };
  } else {
    return {
      entry,
      plugin: mod,
    };
  }
}

/**
 * Extract preset information from a loaded plugin and create a mapping of rules to presets.
 */
function extractRuleToPresetsMapping({
  plugin,
  entry,
}: LoadedPlugin): Map<string, string[]> {
  const ruleToPresets = new Map<string, string[]>();

  if (!plugin.configs) {
    return ruleToPresets;
  }

  // Iterate through all configs/presets, prioritizing flat configs
  for (const [configName, config] of Object.entries(plugin.configs)) {
    // Get the rules from this config - handle both flat config arrays and legacy config objects
    let rules: Record<string, any> | undefined;

    if (Array.isArray(config)) {
      // Flat config format - rules are in the first element
      rules = (config[0] as any)?.rules;
    } else {
      // Legacy config format
      rules = (config as any)?.rules;
    }

    if (!rules) continue;

    // Add this preset to each rule's preset list
    for (const ruleName of Object.keys(rules)) {
      // Handle scoped rule names - extract just the rule name part
      const baseRuleName = ruleName.startsWith(`${entry.prefix}/`)
        ? ruleName.split('/').pop()!
        : ruleName;

      // Format the preset name - prefer flat config names when available
      let presetName: string;
      if (['eslint-js', 'eslint-json', 'eslint-markdown'].includes(entry.id)) {
        presetName = `${entry.id.slice(7)}/${configName}`;
      } else {
        presetName = `${entry.prefix}/${configName}`;
      }

      // Only track rules that belong to this plugin
      const belongsToThisPlugin =
        entry.id === 'eslint-js'
          ? !ruleName.includes('/')
          : ruleName.startsWith(`${entry.prefix}/`);

      if (belongsToThisPlugin) {
        const currentPresets = ruleToPresets.get(baseRuleName) || [];
        if (!currentPresets.includes(presetName)) {
          currentPresets.push(presetName);
        }
        ruleToPresets.set(baseRuleName, currentPresets);
      }
    }
  }

  return ruleToPresets;
}

/**
 * Remove unnecessary comments that are generated by `json-schema-to-typescript`.
 */
function cleanJsDoc(content: string): string {
  const patterns: RegExp[] = [
    /\* This interface was referenced by .+ JSON-Schema definition/,
    /\* via the `.+` "/,
  ];

  return content
    .split('\n')
    .filter((line) => !patterns.some((ignoredLine) => ignoredLine.test(line)))
    .join('\n')
    .replace(/\/\*\*\n\s+\*\//g, '\n');
}

/**
 * Replace some types that are generated by `json-schema-to-typescript`.
 */
function patchTypes(content: string): string {
  const replacements: Array<[pattern: RegExp, replacement: string]> = [
    [/\(string(?: & {\s*\[k: string]: any\s*}){2}\)\[]/, 'string[]'],
    [/\(string & {\s*\[k: string]: any\s*}\)\[]/, 'string[]'],
    [/;\n\s*\[k: string]: any;/, '; & {\n  [k: string]: any;'],
  ];

  for (const [pattern, replacement] of replacements) {
    content = content.replace(pattern, replacement);
  }

  if (/^export type \w+Option = \(\[]\|/.test(content)) {
    content = content.replaceAll('| []|', '|');
  }

  return content;
}

/**
 * Generate a type from the given JSON schema.
 */
async function generateTypeFromSchema(
  schema: JSONSchema4,
  typeName: string,
): Promise<string> {
  schema = JSON.parse(
    JSON.stringify(schema).replaceAll('#/items/0/$defs/', '#/$defs/'),
  );
  let result = await compile(schema, typeName, {
    format: false,
    bannerComment: '',
    unknownAny: false,
  });

  result = cleanJsDoc(result);
  result = patchTypes(result);

  return result;
}

async function generateRule(
  entry: PluginEntry,
  ruleName: string,
  rule: Rule.RuleModule,
  rulePresets?: string[],
) {
  let content = '';
  let optionText = '';
  let configText = '';
  let settingText = '';

  const pascalName = pascalCase(ruleName);
  const pascal = (name: string) => pascalName + pascalCase(name);

  const schema = rule.meta?.schema;
  const isArray = Array.isArray(schema);

  const mainSchema = isArray ? schema[0] : schema;
  const sideSchema = isArray && schema.length > 1 ? schema[1] : undefined;
  const thirdSchema = isArray && schema.length > 2 ? schema[2] : undefined;
  const isSchemaArray = isArray;

  /**
   * Generate a JSDoc with the rule description and `@see` url.
   */
  function generateTypeJsDoc(): string {
    const { meta } = rule;

    /**
     * Build the rule description to append to the JSDoc.
     */
    let description = rule.meta?.docs?.description ?? '';
    description = description.charAt(0).toUpperCase() + description.slice(1);
    if (description.length > 0 && !description.endsWith('.')) {
      description += '.';
    }

    /**
     * Build the `@see` url to the rule documentation to append to the JSDoc.
     */
    const seeDocLink = meta?.docs?.url
      ? `@see [${ruleName}](${meta.docs.url})`
      : '';

    /**
     * Build preset information to show which configs include this rule.
     */
    const presetsInfo = rulePresets?.length
      ? `@preset ${rulePresets.map((c) => '`' + c + '`').join(', ')}`
      : '';

    return concatDoc([
      description.replace('*/', ''),
      rule.meta?.deprecated ? '@deprecated' : '',
      presetsInfo,
      seeDocLink,
    ]);
  }

  /**
   * Generate a type from a JSON schema and append it to the file content.
   */
  async function appendJsonSchemaType(schema: JSONSchema4, name: string) {
    const type = await generateTypeFromSchema(schema, pascal(name));
    return `\n${type}\n`;
  }

  /**
   * Scoped rule name ESLint config uses.
   */
  function prefixedRuleName(): string {
    const { prefix, id } = entry;
    return id === 'eslint-js' ? ruleName : `${prefix}/${ruleName}`;
  }

  function writeMember(
    name: 'option' | 'config' | 'setting',
    nullable: boolean,
  ) {
    const text = {
      option: optionText,
      config: configText,
      setting: settingText,
    }[name];

    const stripped = text
      .replace(`export type ${pascal(name)} =`, '')
      .replace(`export interface ${pascal(name)} `, '')
      .trim()
      .replace(/^\(/, '')
      .replace(/\)$/, '')
      .trim();

    if (isSimpleType(stripped)) {
      return {
        simple: true as const,
        raw: stripped,
        text: `(${stripped})?`,
      };
    } else {
      content += text;
      return {
        simple: false as const,
        text: `${pascal(name)}${nullable ? '?' : ''}`,
      };
    }
  }

  // Generate and append types for the rule schemas.
  if (thirdSchema) {
    settingText += await appendJsonSchemaType(thirdSchema, 'Setting');
  }

  if (sideSchema) {
    configText += await appendJsonSchemaType(sideSchema, 'Config');
  }

  if (mainSchema) {
    optionText += await appendJsonSchemaType(mainSchema, 'Option');
  }

  // Append the rule type options to the file content.
  let type = '';
  let isSingleOptional: string | undefined;

  if (mainSchema) {
    if (!isSchemaArray) {
      type = writeMember('option', false).text;
    } else if (thirdSchema) {
      type = arr(
        writeMember('option', true),
        writeMember('config', true),
        writeMember('setting', true),
      );
    } else if (sideSchema) {
      type = arr(writeMember('option', true), writeMember('config', true));
    } else if (mainSchema) {
      const result = writeMember('option', true);
      type = arr(result);
      if (result.simple) {
        isSingleOptional = result.raw;
      }
    }
  }

  const needsNamespace = occurrences(content, 'export') > 1;
  let ruleType: string;

  if (!needsNamespace && isSingleOptional) {
    ruleType = `[(${isSingleOptional})?]`;
  } else if (needsNamespace || (mainSchema && type.length > 50)) {
    content += `export type ${pascalName}RuleConfig = ${type};\n`;
    type = `${pascalName}RuleConfig`;
  }

  let prefix = '';
  let suffix = '';
  if (needsNamespace) {
    prefix += `export namespace ${pascalName} {`;
    suffix += '}';
  }

  ruleType ??= mainSchema
    ? `${needsNamespace ? `${pascalName}.${type}` : type}`
    : 'null';

  // Append the final rule interface to the file content.
  let property = `${generateTypeJsDoc()}\n`;
  property += `'${prefixedRuleName()}': ${ruleType};`;

  return {
    content: [prefix, content, suffix].join('\n'),
    property,
    meta: rule.meta,
  };
}

interface FailedRule {
  ruleName: string;
  err: unknown;
}

/**
 * Generate the `index.d.ts` file for the plugin's rules that will re-export all rules.
 */
async function generateRuleFile(
  outDir: string,
  filename: string,
  { plugin: { rules }, entry: { name } }: LoadedPlugin,
  { failedRules, ruleDetails }: RulesFile,
): Promise<void> {
  if (!rules) {
    throw new Error(
      `Plugin ${name} doesn't have any rules. Did you forget to load them?`,
    );
  }

  // Write the final `index.d.ts` file.
  const fileContent = `
    import type { RuleConfig, RulesObject } from '../rule-config';

    ${[...ruleDetails.values()].map((r) => r.content).join('\n')}

    ${concatDoc([`All ${name} rules.`])}
    export interface ${name}Rules {
      ${Object.keys(rules)
        .filter(
          (ruleName) =>
            !failedRules.some((failedRule) => failedRule.ruleName === ruleName),
        )
        .map((name) => ruleDetails.get(name)!.property)
        .join('\n\n')}
    }

    export type ${name}RulesObject = RulesObject<${name}Rules>;
  `;

  const rulePath = join(outDir, filename);
  try {
    await fs.writeFile(rulePath, await format(fileContent));
  } catch (error) {
    await fs.writeFile(rulePath, fileContent);
  }
}

/**
 * Print a report after having generated rules files for a plugin.
 */
function printGenerationReport(
  rules: Array<[string, Rule.RuleModule]>,
  failedRules: FailedRule[],
): void {
  const msg = `  ✅ Generated ${rules.length - failedRules.length} rules`;
  logger.logUpdate(colors.green(msg));
  logger.logUpdatePersist();

  if (failedRules.length > 0) {
    logger.log(colors.red(`  ❌ Failed ${failedRules.length} rules`));
    for (const { ruleName, err } of failedRules) {
      logger.log(colors.red(`    - ${ruleName}: ${String(err)}`));
    }
  }

  logger.log('');
}

function occurrences(source: string, find: string) {
  let count = 0;
  let pos = -find.length;
  while ((pos = source.indexOf(find, pos + find.length)) > -1) {
    count++;
  }

  return count;
}

const isSimpleType = (type: string) =>
  /^("[^"]+" \| )*"[^"]+"$/.test(type) ||
  /^{(\s*\w+\??: [\w[\]]+\n)+\s*}$/.test(type);

const arr = (...members: Array<{ text: string }>): string =>
  `[${members.map((x) => x.text).join(', ')}]`;

type RuleDetail = Awaited<ReturnType<typeof generateRule>>;
type RulesFile = Awaited<ReturnType<typeof generateRulesFile>>;

/**
 * Generate a `.d.ts` file for each rule in the given plugin.
 */
async function generateRulesFile(loadedPlugin: LoadedPlugin) {
  const { plugin, entry } = loadedPlugin;
  const failedRules: FailedRule[] = [];
  const ruleDetails = new Map</* ruleName */ string, RuleDetail>();

  const pluginRules = plugin.rules;
  if (!pluginRules) {
    throw new Error(
      `Plugin ${entry.name} doesn't have any rules. Did you forget to load them?`,
    );
  }

  // Extract rule-to-presets mapping
  const ruleToPresets = extractRuleToPresetsMapping(loadedPlugin);

  const rules: Array<[string, Rule.RuleModule]> = Object.entries(pluginRules);
  for (const [ruleName, rule] of rules) {
    logger.logUpdate(colors.yellow(`  Generating > ${ruleName}`));

    try {
      const presets = ruleToPresets.get(ruleName);
      ruleDetails.set(
        ruleName,
        await generateRule(entry, ruleName, rule, presets),
      );
    } catch (error) {
      failedRules.push({ ruleName, err: error });
    }
  }

  printGenerationReport(rules, failedRules);

  return { failedRules, ruleDetails };
}

async function generateRuleIndex(file: string, plugins: PluginEntry[]) {
  const source = await fs.readFile(file, 'utf8');
  const replaced = new RegionReplacer(source)
    .replace(
      'imports',
      plugins
        .map((_) => `import type { ${_.name}RulesObject } from './${_.id}';`)
        .join('\n'),
    )
    .replace('union', plugins.map((_) => `${_.name}RulesObject,`).join('\n'))
    .get();
  await fs.writeFile(file, await format(replaced));
}

const mkdirpSync = (dir: string) => fs.mkdir(dir, { recursive: true });

export type RuleData = Array<{
  plugin: PluginEntry;
  ruleDetails: Array<Pick<RuleDetail, 'meta'> & { name: string }>;
}>;

export async function run(): Promise<void> {
  const rulesDir = join(import.meta.dirname, '../src/rules');
  await mkdirpSync(rulesDir);
  const programmaticData: RuleData = [];

  const extendsCollector = new ExtendsCollector();

  for (const plugin of PLUGIN_REGISTRY) {
    try {
      logger.info(`Generating ${plugin.name} rules.`);
      logger.logUpdate(colors.yellow(`  Loading plugin > ${plugin.id}`));
      const loadedPlugin = await loadPlugin(plugin);
      extendsCollector.add(loadedPlugin);

      const rulesFile = await generateRulesFile(loadedPlugin);
      await generateRuleFile(
        rulesDir,
        `${plugin.id}.d.ts`,
        loadedPlugin,
        rulesFile,
      );

      const ruleDetails = [...rulesFile.ruleDetails].flatMap(
        ([name, { meta }]) => ({ name, meta }),
      );

      programmaticData.push({
        plugin: loadedPlugin.entry,
        ruleDetails,
      });
    } catch (e) {
      console.error((e as Error).stack);
      throw e;
    }
  }

  await generateRuleIndex(
    join(import.meta.dirname, '../src/rules/index.d.ts'),
    PLUGIN_REGISTRY,
  );
  await extendsCollector.write();

  // await fs.writeFile(
  //   join(import.meta.dirname, '../src/data.json'),
  //   JSON.stringify(programmaticData),
  // );
}
