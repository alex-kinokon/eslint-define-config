import { Logger } from '@poppinss/cliui';
import { kebabCase, pascalCase } from 'change-case';
import type { Rule } from 'eslint';
import type { JSONSchema4 } from 'json-schema';
import { compile } from 'json-schema-to-typescript';
import { execSync } from 'node:child_process';
import { existsSync, mkdirSync, writeFileSync } from 'node:fs';
import { join, resolve } from 'node:path';
import { URL, fileURLToPath } from 'node:url';
import colors from 'picocolors';
import { format as prettierFormat } from 'prettier';

const logger = new Logger();

type PluginRules = Record<string, Rule.RuleModule>;

interface Plugin {
  name: string;
  prefix?: string;
  module: string;
  rules?: PluginRules;
}

/**
 * Format the given content with Prettier.
 */
function format(content: string) {
  return prettierFormat(content, {
    plugins: ['prettier-plugin-organize-imports'],
    parser: 'typescript',
    singleQuote: true,
    trailingComma: 'all',
  });
}

function concatDoc(lines: string[]) {
  lines = lines.filter(Boolean);
  if (!lines.length || lines.every((line) => !line.trim())) {
    return '';
  }

  return ['/**', ...lines.map((line) => ` * ${line}`), ' */'].join('\n');
}

/**
 * Map of plugins for which the script will generate rule files.
 */
export const PLUGIN_REGISTRY: Readonly<Record<string, Plugin>> = {
  deprecation: {
    name: 'Deprecation',
    module: 'eslint-plugin-deprecation',
  },
  eslint: {
    name: 'Eslint',
    module: 'eslint',
  },
  'typescript-eslint': {
    name: 'TypeScript',
    prefix: '@typescript-eslint',
    module: '@typescript-eslint/eslint-plugin',
  },
  import: {
    name: 'Import',
    module: 'eslint-plugin-import',
  },
  'eslint-comments': {
    name: 'EslintComments',
    module: 'eslint-plugin-eslint-comments',
  },
  'graphql-eslint': {
    name: 'GraphQL',
    prefix: '@graphql-eslint',
    module: '@graphql-eslint/eslint-plugin',
  },
  jsdoc: {
    name: 'JSDoc',
    prefix: 'jsdoc',
    module: 'eslint-plugin-jsdoc',
  },
  jsonc: {
    name: 'Jsonc',
    module: 'eslint-plugin-jsonc',
  },
  'jsx-a11y': {
    name: 'JsxA11y',
    module: 'eslint-plugin-jsx-a11y',
  },
  mdx: {
    name: 'Mdx',
    module: 'eslint-plugin-mdx',
  },
  n: {
    name: 'N',
    module: 'eslint-plugin-n',
  },
  node: {
    name: 'Node',
    module: 'eslint-plugin-node',
  },
  promise: {
    name: 'Promise',
    module: 'eslint-plugin-promise',
  },
  react: {
    name: 'React',
    module: 'eslint-plugin-react',
  },
  'react-hooks': {
    name: 'ReactHooks',
    module: 'eslint-plugin-react-hooks',
  },
  sonarjs: {
    name: 'SonarJS',
    prefix: 'sonarjs',
    module: 'eslint-plugin-sonarjs',
  },
  spellcheck: {
    name: 'Spellcheck',
    module: 'eslint-plugin-spellcheck',
  },
  'testing-library': {
    name: 'TestingLibrary',
    module: 'eslint-plugin-testing-library',
  },
  unicorn: {
    name: 'Unicorn',
    module: 'eslint-plugin-unicorn',
  },
  vitest: {
    name: 'Vitest',
    module: 'eslint-plugin-vitest',
  },
  vue: {
    name: 'Vue',
    module: 'eslint-plugin-vue',
  },
  'vue-i18n': {
    name: 'VueI18n',
    prefix: '@intlify/vue-i18n',
    module: '@intlify/eslint-plugin-vue-i18n',
  },
  'vue-pug': {
    name: 'VuePug',
    module: 'eslint-plugin-vue-pug',
  },
  yml: {
    name: 'Yml',
    module: 'eslint-plugin-yml',
  },
  'import-x': {
    name: 'ImportX',
    module: 'eslint-plugin-import-x',
  },
} as const;

async function loadPlugin(plugin: Plugin): Promise<Plugin> {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const mod: any = await import(plugin.module);
  const rules: PluginRules =
    plugin.module === 'eslint'
      ? Object.fromEntries(
          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
          new mod.Linter().getRules().entries(),
        )
      : mod.rules ?? mod.default.rules;
  return { ...plugin, rules };
}

/**
 * Remove unnecessary comments that are generated by `json-schema-to-typescript`.
 */
function cleanJsDoc(content: string): string {
  const patterns: RegExp[] = [
    /\* This interface was referenced by .+ JSON-Schema definition/,
    /\* via the `.+` "/,
  ];

  return content
    .split('\n')
    .filter((line) => !patterns.some((ignoredLine) => ignoredLine.test(line)))
    .join('\n');
}

/**
 * Replace some types that are generated by `json-schema-to-typescript`.
 */
function patchTypes(content: string): string {
  const replacements: Array<[pattern: RegExp, replacement: string]> = [
    [
      /\(string & \{\s*\[k: string\]: any\s*\} & \{\s*\[k: string\]: any\s*\}\)\[\]/,
      'string[]',
    ],
    [/\(string & \{\s*\[k: string\]: any\s*\}\)\[\]/, 'string[]'],
    [/;\n\s*\[k: string\]: any;/, '; & {\n  [k: string]: any;'],
  ];

  for (const [pattern, replacement] of replacements) {
    content = content.replace(pattern, replacement);
  }

  if (/^export type \w+Option = \(\[\]\|/.test(content)) {
    content = content.replaceAll('| []|', '|');
  }

  return content;
}

/**
 * Generate a type from the given JSON schema.
 */
async function generateTypeFromSchema(
  schema: JSONSchema4,
  typeName: string,
): Promise<string> {
  schema = JSON.parse(
    JSON.stringify(schema).replace(/#\/items\/0\/\$defs\//g, '#/$defs/'),
  );
  let result = await compile(schema, typeName, {
    format: false,
    bannerComment: '',
    unknownAny: false,
  });

  result = cleanJsDoc(result);
  result = patchTypes(result);

  return result;
}

const __dirname: string = fileURLToPath(new URL('.', import.meta.url));

class RuleFile {
  private content = '';
  private readonly ruleNamePascalCase: string;
  private readonly isSchemaArray!: boolean;
  private readonly mainSchema?: JSONSchema4;
  private readonly sideSchema?: JSONSchema4;
  private readonly thirdSchema?: JSONSchema4;

  private optionText = '';
  private configText = '';
  private settingText = '';

  constructor(
    private readonly plugin: Plugin,
    private readonly ruleName: string,
    private readonly rule: Rule.RuleModule,
  ) {
    this.ruleNamePascalCase = pascalCase(this.ruleName);

    const schema = this.rule.meta?.schema;
    const isArray = Array.isArray(schema);

    this.mainSchema = isArray ? schema[0] : schema;
    this.sideSchema = isArray && schema.length > 1 ? schema[1] : undefined;
    this.thirdSchema = isArray && schema.length > 2 ? schema[2] : undefined;
    this.isSchemaArray = isArray;
  }

  /**
   * Generate a JSDoc with the rule description and `@see` url.
   */
  private generateTypeJsDoc(): string {
    const { meta } = this.rule;

    /**
     * Build the rule description to append to the JSDoc.
     */
    let description = this.rule.meta?.docs?.description ?? '';
    description = description.charAt(0).toUpperCase() + description.slice(1);
    if (description.length && !description.endsWith('.')) {
      description += '.';
    }

    /**
     * Build the `@see` url to the rule documentation to append to the JSDoc.
     */
    const seeDocLink = meta?.docs?.url
      ? `@see [${this.ruleName}](${meta.docs.url})`
      : '';

    return concatDoc([
      description.replace('*/', ''),
      this.rule.meta?.deprecated ? '@deprecated' : '',
      seeDocLink,
    ]);
  }

  /**
   * Generate a type from a JSON schema and append it to the file content.
   */
  private async appendJsonSchemaType(schema: JSONSchema4, name: string) {
    const type = await generateTypeFromSchema(schema, this.pascal(name));
    return `\n${type}\n`;
  }

  /**
   * Generate and append types for the rule schemas.
   */
  private async appendRuleSchemaTypes(): Promise<void> {
    if (this.thirdSchema) {
      this.settingText += await this.appendJsonSchemaType(
        this.thirdSchema,
        'Setting',
      );
    }

    if (this.sideSchema) {
      this.configText += await this.appendJsonSchemaType(
        this.sideSchema,
        'Config',
      );
    }

    if (this.mainSchema) {
      this.optionText += await this.appendJsonSchemaType(
        this.mainSchema,
        'Option',
      );
    }
  }

  /**
   * Scoped rule name ESLint config uses.
   */
  private prefixedRuleName(): string {
    const { prefix, name } = this.plugin;
    let rulePrefix = (prefix ?? kebabCase(name)) + '/';

    if (name === 'Eslint') {
      rulePrefix = '';
    }

    return `${rulePrefix}${this.ruleName}`;
  }

  private pascal(name: string) {
    return this.ruleNamePascalCase + pascalCase(name);
  }

  private writeMember(
    name: 'option' | 'config' | 'setting',
    nullable: boolean,
  ) {
    const text = this[`${name}Text`];
    const stripped = text
      .replace(`export type ${this.pascal(name)} =`, '')
      .replace(`export interface ${this.pascal(name)} `, '')
      .trim()
      .replace(/^\(/, '')
      .replace(/\)$/, '')
      .trim();

    // if (text.includes('exceptions')) {
    //   console.log({
    //     name: this.ruleName,
    //     text: text.slice(0, 50),
    //     stripped,
    //     is: isSimpleType(stripped),
    //   });
    // }

    if (isSimpleType(stripped)) {
      return `(${stripped})?`;
    } else {
      this.content += text;
      return `${this.pascal(name)}${nullable ? '?' : ''}`;
    }
  }

  /**
   * Generate a file with the rule typings.
   */
  async generate() {
    const ruleName = this.ruleNamePascalCase;

    await this.appendRuleSchemaTypes();

    /**
     * Append the rule type options to the file content.
     */
    let type = '';
    if (this.mainSchema) {
      if (!this.isSchemaArray) {
        type = this.writeMember('option', false);
      } else if (this.thirdSchema) {
        type = arr(
          this.writeMember('option', true),
          this.writeMember('config', true),
          this.writeMember('setting', true),
        );
      } else if (this.sideSchema) {
        type = arr(
          this.writeMember('option', true),
          this.writeMember('config', true),
        );
      } else if (this.mainSchema) {
        type = arr(this.writeMember('option', true));
      }
    }

    const needsNamespace = occurrences(this.content, 'export') > 1;

    if (needsNamespace || (this.mainSchema && type.length > 50)) {
      this.content += `export type ${ruleName}RuleConfig = ${type};\n`;
      type = `${ruleName}RuleConfig`;
    }

    let prefix = '';
    let suffix = '';
    if (needsNamespace) {
      prefix += `export namespace ${ruleName} {`;
      suffix += '}';
    }

    const ruleType = this.mainSchema
      ? `RuleConfig<${needsNamespace ? `${ruleName}.${type}` : type}>`
      : 'EmptyRuleConfig';

    /**
     * Append the final rule interface to the file content.
     */
    let property = `${this.generateTypeJsDoc()}\n`;
    property += `'${this.prefixedRuleName()}': ${ruleType};`;

    return {
      reference: `${ruleName}Rule`,
      content: [prefix, this.content, suffix].join('\n'),
      property,
    };
  }
}

interface FailedRule {
  ruleName: string;
  err: unknown;
}

/**
 * Generate the `index.d.ts` file for the plugin's rules that will re-export all rules.
 */
async function generateRuleFile(
  outDir: string,
  filename: string,
  { rules, name }: Plugin,
  { failedRules, ruleDetails }: RulesFile,
): Promise<void> {
  if (!rules) {
    throw new Error(
      `Plugin ${name} doesn't have any rules. Did you forget to load them?`,
    );
  }

  const generatedRules = Object.keys(rules).filter(
    (ruleName) =>
      !failedRules.some((failedRule) => failedRule.ruleName === ruleName),
  );

  /**
   * Build all the import statements for the rules.
   */
  const rulesTexts = Array.from(ruleDetails.values())
    .map((r) => r.content)
    .join('\n');

  /**
   * Build the exported type that is an intersection of all the rules.
   */
  const rulesFinalIntersection = generatedRules
    .map((name) => ruleDetails.get(name)!.property)
    .join('\n\n');

  const pluginRulesType = `
    ${concatDoc([`All ${name} rules.`])}
    export interface ${name}Rules {
      ${rulesFinalIntersection}
    }
  `;

  /**
   * Write the final `index.d.ts` file.
   */
  const fileContent = `
    import type { RuleConfig, EmptyRuleConfig } from '../rule-config';

    ${rulesTexts}

    ${pluginRulesType}
  `;

  const rulePath = join(outDir, filename);
  try {
    writeFileSync(rulePath, await format(fileContent));
  } catch (e) {
    console.error(e);
    writeFileSync(rulePath, fileContent);
  }

  /**
   * Apply a patch to the generated content if a diff file exists for it.
   *
   * Must be called after `generate()`.
   */
  const diffFile = resolve(__dirname, 'diffs', `${filename}.diff`);
  if (existsSync(diffFile)) {
    logger.logUpdate(colors.yellow(`  🧹 Adjusting ${name}`));
    logger.logUpdatePersist();

    execSync(`git apply ${diffFile}`);
  }
}

/**
 * Print a report after having generated rules files for a plugin.
 */
function printGenerationReport(
  rules: Array<[string, Rule.RuleModule]>,
  failedRules: FailedRule[],
): void {
  const msg = `  ✅ Generated ${rules.length - failedRules.length} rules`;
  logger.logUpdate(colors.green(msg));
  logger.logUpdatePersist();

  if (failedRules.length) {
    logger.log(colors.red(`  ❌ Failed ${failedRules.length} rules`));
    failedRules.forEach(({ ruleName, err }) => {
      logger.log(colors.red(`    - ${ruleName}: ${String(err)}`));
    });
  }

  logger.log('');
}

function occurrences(source: string, find: string) {
  let count = 0;
  let pos = -find.length;
  while ((pos = source.indexOf(find, pos + find.length)) > -1) {
    count++;
  }

  return count;
}

const isSimpleType = (type: string) =>
  /^("[^"]+" \| )*"[^"]+"$/.test(type) ||
  /^\{(\s*\w+\??: [\w[\]]+\n)+\s*\}$/.test(type);

const arr = (...members: string[]): string => `[${members.join(', ')}]`;

type RuleDetail = Awaited<ReturnType<RuleFile['generate']>>;
type RulesFile = Awaited<ReturnType<typeof generateRulesFile>>;

/**
 * Generate a `.d.ts` file for each rule in the given plugin.
 */
async function generateRulesFile(plugin: Plugin) {
  const failedRules: FailedRule[] = [];
  const ruleDetails = new Map</* ruleName */ string, RuleDetail>();

  const pluginRules = plugin.rules;
  if (!pluginRules) {
    throw new Error(
      `Plugin ${plugin.name} doesn't have any rules. Did you forget to load them?`,
    );
  }

  const rules: Array<[string, Rule.RuleModule]> = Object.entries(pluginRules);
  for (const [ruleName, rule] of rules) {
    logger.logUpdate(colors.yellow(`  Generating > ${ruleName}`));

    const ruleFile = new RuleFile(plugin, ruleName, rule);
    try {
      ruleDetails.set(ruleName, await ruleFile.generate());
    } catch (err) {
      failedRules.push({ ruleName, err });
    }
  }

  printGenerationReport(rules, failedRules);

  return { failedRules, ruleDetails };
}

export interface RunOptions {
  plugins?: string[];
  targetDirectory?: string;
}

export async function run(options: RunOptions = {}): Promise<void> {
  const { plugins, targetDirectory } = options;

  const wantedPlugins = plugins ?? Object.keys(PLUGIN_REGISTRY);

  const outDir = targetDirectory ?? join(__dirname, '../src/rules');
  mkdirSync(outDir, { recursive: true });

  for (const pluginName of wantedPlugins) {
    const plugin = PLUGIN_REGISTRY[pluginName];
    if (!plugin) {
      throw new Error(`Plugin ${pluginName} doesn't exist.`);
    }

    logger.info(`Generating ${plugin.name} rules.`);
    logger.logUpdate(colors.yellow(`  Loading plugin > ${plugin.module}`));
    const loadedPlugin = await loadPlugin(plugin);
    await generateRuleFile(
      outDir,
      `${pluginName}.d.ts`,
      loadedPlugin,
      await generateRulesFile(loadedPlugin),
    );
  }
}
